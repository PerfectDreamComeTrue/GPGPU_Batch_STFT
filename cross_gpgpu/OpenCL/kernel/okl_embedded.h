
#pragma once
//generated with python code
#include <string>
class okl_embed {
    public:
    std::string compiled_code = 
	"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
	"\n"
	"// #include <math.h>\n"
	"// #include <cstdio>\n"
	"\n"
	"typedef struct complex_t {\n"
	"  float real, imag;\n"
	"} complex;\n"
	"\n"
	"typedef struct pairs_t {\n"
	"  unsigned int first, second;\n"
	"} pairs;\n"
	"\n"
	"typedef struct stockhamPairs {\n"
	"  unsigned int lload, rload, lsave, rsave;\n"
	"} spair;\n"
	"\n"
	"inline float window_func(const int index,\n"
	"                         const int window_size);\n"
	"\n"
	"inline float window_func(const int index,\n"
	"                         const int window_size) {\n"
	"  float normalized_index = (float) index;\n"
	"  normalized_index /= ((float) (window_size - 1));\n"
	"  float angle = 2.0f * M_PI * normalized_index;\n"
	"  return 0.5f * (1.0f - cos(angle));\n"
	"}\n"
	"\n"
	"inline int reverseBits(int num,\n"
	"                       int radix_2_data);\n"
	"\n"
	"inline int reverseBits(int num,\n"
	"                       int radix_2_data) {\n"
	"  int reversed = 0;\n"
	"  for (int i = 0; i < radix_2_data; ++i) {\n"
	"    reversed = (reversed << 1) | (num & 1);\n"
	"    num >>= 1;\n"
	"  }\n"
	"  return reversed;\n"
	"}\n"
	"\n"
	"pairs indexer(const unsigned int firstMaximumID,\n"
	"              const int powed_stage);\n"
	"\n"
	"pairs indexer(const unsigned int firstMaximumID,\n"
	"              const int powed_stage) {\n"
	"  pairs temp;\n"
	"  temp.first = firstMaximumID + (firstMaximumID & (~(powed_stage - 1)));\n"
	"  temp.second = temp.first + powed_stage;\n"
	"  return temp;\n"
	"}\n"
	"\n"
	"inline spair stockhamIndexer(const int localIdx,\n"
	"                             const int segmentSize,\n"
	"                             const unsigned int HalfWinSize);\n"
	"\n"
	"inline spair stockhamIndexer(const int localIdx,\n"
	"                             const int segmentSize,\n"
	"                             const unsigned int HalfWinSize) {\n"
	"  spair res;\n"
	"  res.lload = localIdx + (localIdx & (~(segmentSize - 1)));\n"
	"  res.rload = res.lload + segmentSize;\n"
	"  res.lsave = localIdx;\n"
	"  res.rsave = HalfWinSize + res.lsave;\n"
	"  return res;\n"
	"}\n"
	"\n"
	"\n"
	"// pairs\n"
	"// indexing(const unsigned int ID,const int powed_stage)\n"
	"// {\n"
	"//     pairs temp;\n"
	"//     temp.first = ID;\n"
	"//     temp.second = ID + (ID % (powed_stage*2) >= powed_stage ? -powed_stage : powed_stage);\n"
	"//     return temp;\n"
	"// }\n"
	"\n"
	"inline int calculateK(int windowIDX,\n"
	"                      int powed_stage,\n"
	"                      int windowSize);\n"
	"\n"
	"inline int calculateK(int windowIDX,\n"
	"                      int powed_stage,\n"
	"                      int windowSize) {\n"
	"  return ((windowIDX % powed_stage) * windowSize) / (powed_stage * 2);\n"
	"}\n"
	"\n"
	"inline int segmentK(const int lsave,\n"
	"                    const int segmentSize,\n"
	"                    const int HwindowSize);\n"
	"\n"
	"inline int segmentK(const int lsave,\n"
	"                    const int segmentSize,\n"
	"                    const int HwindowSize) {\n"
	"  // return lsave;\n"
	"  // return calculateK(lsave, segmentSize, windowSize);\n"
	"  return ((lsave % segmentSize) * HwindowSize) / segmentSize;\n"
	"}\n"
	"\n"
	"complex twiddle(int k,\n"
	"                int windowSize);\n"
	"\n"
	"complex twiddle(int k,\n"
	"                int windowSize) {\n"
	"  complex temp;\n"
	"  float angle = -2.0 * M_PI * ((float) k / (float) windowSize);\n"
	"  temp.real = cos(angle);\n"
	"  temp.imag = sin(angle);\n"
	"  return temp;\n"
	"}\n"
	"\n"
	"inline complex cmult(const complex a,\n"
	"                     const complex b);\n"
	"\n"
	"inline complex cmult(const complex a,\n"
	"                     const complex b) {\n"
	"  complex result;\n"
	"  result.real = a.real * b.real - a.imag * b.imag;\n"
	"  result.imag = a.real * b.imag + a.imag * b.real;\n"
	"  return result;\n"
	"}\n"
	"\n"
	"inline complex cadd(complex a,\n"
	"                    const complex b);\n"
	"\n"
	"inline complex cadd(complex a,\n"
	"                    const complex b) {\n"
	"  a.real += b.real;\n"
	"  a.imag += b.imag;\n"
	"  return a;\n"
	"}\n"
	"\n"
	"inline complex csub(complex a,\n"
	"                    const complex b);\n"
	"\n"
	"inline complex csub(complex a,\n"
	"                    const complex b) {\n"
	"  a.real -= b.real;\n"
	"  a.imag -= b.imag;\n"
	"  return a;\n"
	"}\n"
	"\n"
	"inline float cmod(complex a);\n"
	"\n"
	"inline float cmod(complex a) {\n"
	"  return (sqrt(\n"
	"    a.real * a.real + a.imag * a.imag\n"
	"  ));\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_removeDC_0(__global complex * buffer,\n"
	"                       const unsigned int OFullSize,\n"
	"                       __global float * qt_buffer,\n"
	"                       const int windowSize);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_removeDC_0(__global complex * buffer,\n"
	"                       const unsigned int OFullSize,\n"
	"                       __global float * qt_buffer,\n"
	"                       const int windowSize) {\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      unsigned int IDX = o_itr + i_itr;\n"
	"      qt_buffer[IDX / windowSize] += buffer[IDX].imag;\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_removeDC_1(__global complex * buffer,\n"
	"                       const unsigned int OFullSize,\n"
	"                       __global float * qt_buffer,\n"
	"                       const int windowSize);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_removeDC_1(__global complex * buffer,\n"
	"                       const unsigned int OFullSize,\n"
	"                       __global float * qt_buffer,\n"
	"                       const int windowSize) {\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      unsigned int IDX = o_itr + i_itr;\n"
	"      buffer[IDX].imag -= (qt_buffer[IDX / windowSize] / (float) windowSize);\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_overlap_N_window_0(__global float * in,\n"
	"                               __global complex * buffer,\n"
	"                               const unsigned int fullSize,\n"
	"                               const unsigned int OFullSize,\n"
	"                               const int windowSize,\n"
	"                               const unsigned int OMove);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_overlap_N_window_0(__global float * in,\n"
	"                               __global complex * buffer,\n"
	"                               const unsigned int fullSize,\n"
	"                               const unsigned int OFullSize,\n"
	"                               const int windowSize,\n"
	"                               const unsigned int OMove) {\n"
	"  {\n"
	"    unsigned int w_num = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int w_itr = 0 + get_local_id(0);\n"
	"      unsigned int FID = w_num + w_itr;\n"
	"      unsigned int read_point = (unsigned int) ((FID) / windowSize) * OMove + ((FID) % windowSize);\n"
	"\n"
	"      buffer[FID].real = read_point >= fullSize ? 0.0 : in[read_point];\n"
	"      // * window_func((FID) % windowSize, windowSize);\n"
	"      buffer[FID].imag = 0.0;\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_overlap_N_window_imag_0(__global float * in,\n"
	"                                    __global complex * buffer,\n"
	"                                    const unsigned int fullSize,\n"
	"                                    const unsigned int OFullSize,\n"
	"                                    const int windowSize,\n"
	"                                    const unsigned int OMove);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_overlap_N_window_imag_0(__global float * in,\n"
	"                                    __global complex * buffer,\n"
	"                                    const unsigned int fullSize,\n"
	"                                    const unsigned int OFullSize,\n"
	"                                    const int windowSize,\n"
	"                                    const unsigned int OMove) {\n"
	"  {\n"
	"    unsigned int w_num = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int w_itr = 0 + get_local_id(0);\n"
	"      unsigned int FID = w_num + w_itr;\n"
	"      unsigned int read_point = (unsigned int) ((FID) / windowSize) * OMove + ((FID) % windowSize);\n"
	"\n"
	"      buffer[FID].imag = read_point >= fullSize ? 0.0 : in[read_point] * window_func(\n"
	"        (FID) % windowSize,\n"
	"        windowSize\n"
	"      );\n"
	"      buffer[FID].real = 0.0;\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_bitReverse_temp_0(__global complex * buffer,\n"
	"                              __global complex * result,\n"
	"                              const unsigned int OFullSize,\n"
	"                              const int windowSize,\n"
	"                              const int radixData);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_bitReverse_temp_0(__global complex * buffer,\n"
	"                              __global complex * result,\n"
	"                              const unsigned int OFullSize,\n"
	"                              const int windowSize,\n"
	"                              const int radixData) {\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int w_itr = 0 + get_local_id(0);\n"
	"      unsigned int Gidx = (o_itr + w_itr);\n"
	"      unsigned int Lidx = (Gidx % windowSize);\n"
	"      unsigned int dst_idx = reverseBits(Lidx, radixData);\n"
	"      unsigned int BID = Gidx - Lidx + dst_idx;\n"
	"      result[BID] = buffer[Gidx];\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_bitReverse_0(__global complex * buffer,\n"
	"                         const unsigned int OFullSize,\n"
	"                         const int windowSize,\n"
	"                         const int radixData);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_bitReverse_0(__global complex * buffer,\n"
	"                         const unsigned int OFullSize,\n"
	"                         const int windowSize,\n"
	"                         const int radixData) {\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int w_itr = 0 + get_local_id(0);\n"
	"      unsigned int dst_idx = reverseBits(((o_itr + w_itr) % windowSize), radixData);\n"
	"      unsigned int BID = o_itr + w_itr - ((o_itr + w_itr) % windowSize) + dst_idx;\n"
	"      buffer[BID].real = buffer[o_itr + w_itr].imag;\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_endPreProcess_0(__global complex * buffer,\n"
	"                            const unsigned int OFullSize);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_endPreProcess_0(__global complex * buffer,\n"
	"                            const unsigned int OFullSize) {\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      buffer[o_itr + i_itr].imag = 0.0;\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(512,1,1)))\n"
	" void _occa_StockhamButterfly10_0(__global complex * buffer,\n"
	"                                  const unsigned int OHalfSize);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(512,1,1)))\n"
	" void _occa_StockhamButterfly10_0(__global complex * buffer,\n"
	"                                  const unsigned int OHalfSize) {\n"
	"  __local complex bank_second[1024];\n"
	"  __local complex bank_first[1024];\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (512 * get_group_id(0));\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      unsigned int global_idx = (o_itr + i_itr);\n"
	"      pairs idx = indexer(global_idx, 512);\n"
	"      spair lidx = stockhamIndexer(i_itr, 512, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 512, 512), 1024);\n"
	"      complex cfirst = buffer[idx.first];\n"
	"      complex csecond = buffer[idx.second];\n"
	"      bank_second[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_second[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 256, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 256, 512), 1024);\n"
	"      complex cfirst = bank_second[lidx.lload];\n"
	"      complex csecond = bank_second[lidx.rload];\n"
	"      bank_first[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_first[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 128, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 128, 512), 1024);\n"
	"      complex cfirst = bank_first[lidx.lload];\n"
	"      complex csecond = bank_first[lidx.rload];\n"
	"      bank_second[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_second[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 64, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 64, 512), 1024);\n"
	"      complex cfirst = bank_second[lidx.lload];\n"
	"      complex csecond = bank_second[lidx.rload];\n"
	"      bank_first[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_first[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 32, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 32, 512), 1024);\n"
	"      complex cfirst = bank_first[lidx.lload];\n"
	"      complex csecond = bank_first[lidx.rload];\n"
	"      bank_second[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_second[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 16, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 16, 512), 1024);\n"
	"      complex cfirst = bank_second[lidx.lload];\n"
	"      complex csecond = bank_second[lidx.rload];\n"
	"      bank_first[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_first[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 8, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 8, 512), 1024);\n"
	"      complex cfirst = bank_first[lidx.lload];\n"
	"      complex csecond = bank_first[lidx.rload];\n"
	"      bank_second[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_second[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 4, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 4, 512), 1024);\n"
	"      complex cfirst = bank_second[lidx.lload];\n"
	"      complex csecond = bank_second[lidx.rload];\n"
	"      bank_first[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_first[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      spair lidx = stockhamIndexer(i_itr, 2, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 2, 512), 1024);\n"
	"      complex cfirst = bank_first[lidx.lload];\n"
	"      complex csecond = bank_first[lidx.rload];\n"
	"      bank_second[lidx.lsave] = cadd(cfirst, csecond);\n"
	"      bank_second[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs GIDX;\n"
	"      GIDX.first = o_itr * 2 + i_itr;\n"
	"      GIDX.second = GIDX.first + 512;\n"
	"      spair lidx = stockhamIndexer(i_itr, 1, 512);\n"
	"      complex thisTwiddle = twiddle(segmentK(lidx.lsave, 1, 512), 1024);\n"
	"      complex cfirst = bank_second[lidx.lload];\n"
	"      complex csecond = bank_second[lidx.rload];\n"
	"      buffer[GIDX.first] = cadd(cfirst, csecond);\n"
	"      buffer[GIDX.second] = cmult(csub(cfirst, csecond), thisTwiddle);\n"
	"    }\n"
	"\n"
	"    // for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)\n"
	"    // {\n"
	"    //     pairs GIDX;\n"
	"    //     GIDX.first = o_itr * 2 + i_itr;\n"
	"    //     GIDX.second= GIDX.first + 512;\n"
	"    //     buffer[GIDX.first] = bank_first[i_itr];\n"
	"    //     buffer[GIDX.second] = bank_first[i_itr + 512];\n"
	"    // }\n"
	"  }\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(512,1,1)))\n"
	" void _occa_OptimizedDIFButterfly10_0(__global complex * buffer,\n"
	"                                      const unsigned int OHalfSize);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(512,1,1)))\n"
	" void _occa_OptimizedDIFButterfly10_0(__global complex * buffer,\n"
	"                                      const unsigned int OHalfSize) {\n"
	"  __local complex bank_second[1024];\n"
	"  __local complex bank_first[1024];\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (512 * get_group_id(0));\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      int global_idx = (o_itr + i_itr);\n"
	"      pairs idx = indexer(global_idx, 512);\n"
	"      pairs Lidx = indexer((i_itr + o_itr) % 512, 512);\n"
	"      complex cfirst = buffer[idx.first];\n"
	"      complex csecond = buffer[idx.second];\n"
	"      complex this_twiddle = twiddle(calculateK(i_itr, 512, 1024), 1024);\n"
	"\n"
	"\n"
	"      bank_second[Lidx.first] = cadd(cfirst, csecond);\n"
	"      bank_second[Lidx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      //debug\n"
	"      buffer[idx.first] = bank_second[Lidx.first];\n"
	"      buffer[idx.second] = bank_second[Lidx.second];\n"
	"      //debug\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 256);\n"
	"      complex cfirst = bank_second[idx.first];\n"
	"      complex csecond = bank_second[idx.second];\n"
	"      complex this_twiddle = twiddle(\n"
	"        calculateK(idx.first, 256, 1024),\n"
	"        1024\n"
	"      );\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_first[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_first[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 256);\n"
	"      buffer[Gidx.first] = bank_first[idx.first];\n"
	"      buffer[Gidx.second] = bank_first[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 128);\n"
	"      complex cfirst = bank_first[idx.first];\n"
	"      complex csecond = bank_first[idx.second];\n"
	"      complex this_twiddle = twiddle(\n"
	"        calculateK(idx.first, 128, 1024),\n"
	"        1024\n"
	"      );\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_second[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_second[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 128);\n"
	"      buffer[Gidx.first] = bank_second[idx.first];\n"
	"      buffer[Gidx.second] = bank_second[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 64);\n"
	"      complex cfirst = bank_second[idx.first];\n"
	"      complex csecond = bank_second[idx.second];\n"
	"      complex this_twiddle = twiddle(\n"
	"        calculateK(idx.first, 64, 1024),\n"
	"        1024\n"
	"      );\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_first[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_first[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 64);\n"
	"      buffer[Gidx.first] = bank_first[idx.first];\n"
	"      buffer[Gidx.second] = bank_first[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 32);\n"
	"      complex cfirst = bank_first[idx.first];\n"
	"      complex csecond = bank_first[idx.second];\n"
	"      complex this_twiddle = twiddle(\n"
	"        calculateK(idx.first, 32, 1024),\n"
	"        1024\n"
	"      );\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_second[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_second[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 32);\n"
	"      buffer[Gidx.first] = bank_second[idx.first];\n"
	"      buffer[Gidx.second] = bank_second[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 16);\n"
	"      complex cfirst = bank_second[idx.first];\n"
	"      complex csecond = bank_second[idx.second];\n"
	"      complex this_twiddle = twiddle(\n"
	"        calculateK(idx.first, 16, 1024),\n"
	"        1024\n"
	"      );\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_first[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_first[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 16);\n"
	"      buffer[Gidx.first] = bank_first[idx.first];\n"
	"      buffer[Gidx.second] = bank_first[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 8);\n"
	"      complex cfirst = bank_first[idx.first];\n"
	"      complex csecond = bank_first[idx.second];\n"
	"      complex this_twiddle = twiddle(calculateK(idx.first, 8, 1024), 1024);\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_second[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_second[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 8);\n"
	"      buffer[Gidx.first] = bank_second[idx.first];\n"
	"      buffer[Gidx.second] = bank_second[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 4);\n"
	"      complex cfirst = bank_second[idx.first];\n"
	"      complex csecond = bank_second[idx.second];\n"
	"      complex this_twiddle = twiddle(calculateK(idx.first, 4, 1024), 1024);\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_first[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_first[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 4);\n"
	"      buffer[Gidx.first] = bank_first[idx.first];\n"
	"      buffer[Gidx.second] = bank_first[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 2);\n"
	"      complex cfirst = bank_first[idx.first];\n"
	"      complex csecond = bank_first[idx.second];\n"
	"      complex this_twiddle = twiddle(calculateK(idx.first, 2, 1024), 1024);\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_second[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_second[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 2);\n"
	"      buffer[Gidx.first] = bank_second[idx.first];\n"
	"      buffer[Gidx.second] = bank_second[idx.second];\n"
	"    }\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      pairs idx = indexer((i_itr + o_itr) % (512), 1);\n"
	"      complex cfirst = bank_second[idx.first];\n"
	"      complex csecond = bank_second[idx.second];\n"
	"      complex this_twiddle = twiddle(calculateK(idx.first, 1, 1024), 1024);\n"
	"      complex tempcplx = cmult(csecond, this_twiddle);\n"
	"      bank_first[idx.first] = cadd(cfirst, csecond);\n"
	"      bank_first[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\n"
	"      pairs Gidx = indexer(i_itr + o_itr, 1);\n"
	"      buffer[Gidx.first] = bank_first[idx.first];\n"
	"      buffer[Gidx.second] = bank_first[idx.second];\n"
	"    }\n"
	"    // for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)\n"
	"    // {\n"
	"    //     @barrier();\n"
	"    //     pairs idx = indexer((i_itr + o_itr) % (1024 / 2), 512);\n"
	"    //     complex cfirst = bank_second[idx.first];\n"
	"    //     complex csecond = bank_second[idx.second];\n"
	"\n"
	"    //     complex this_twiddle = twiddle(calculateK(idx.first, 512, 1024), 1024);\n"
	"    //     complex tempcplx = cmult(csecond, this_twiddle);\n"
	"\n"
	"    //     pairs Gidx = indexer(i_itr + o_itr, 512);\n"
	"    //     buffer[Gidx.first] = cadd(cfirst, tempcplx);\n"
	"    //     buffer[Gidx.second] = csub(cfirst, tempcplx);\n"
	"\n"
	"    //     bank_first[idx.first] = cadd(cfirst, tempcplx);\n"
	"    //     bank_first[idx.second] = csub(cfirst, tempcplx);\n"
	"    // }\n"
	"    // for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)\n"
	"    // {\n"
	"    //     pairs idx = indexer(i_itr, 256);\n"
	"    //     complex cfirst = bank_first[idx.first];\n"
	"    //     complex csecond = bank_first[idx.second];\n"
	"\n"
	"    //     complex this_twiddle = twiddle(calculateK(idx.first, 256, 1024), 1024);\n"
	"    //     complex tempcplx = cmult(csecond, this_twiddle);\n"
	"    //     pairs GIDX = indexer(o_itr + i_itr, 256);\n"
	"    //     buffer[GIDX.first] = cadd(cfirst, tempcplx);\n"
	"    //     buffer[GIDX.second] = csub(cfirst, tempcplx);\n"
	"    // }\n"
	"    // for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)\n"
	"    // {\n"
	"    //     pairs LIDX = indexer((i_itr + o_itr) % 512, 512);\n"
	"    //     pairs GIDX = indexer(i_itr + o_itr, 512);\n"
	"    //     // o_itr = 432153245;\n"
	"    //     complex cfirst = buffer[GIDX.first];\n"
	"    //     complex csecond = buffer[GIDX.second];\n"
	"    //     complex this_twiddle = twiddle(calculateK(GIDX.first, 512, 1024), 1024);\n"
	"    //     complex tempcplx = cmult(csecond, this_twiddle);\n"
	"    //     buffer[GIDX.first] = cadd(cfirst, tempcplx);\n"
	"    //     buffer[GIDX.second] = csub(cfirst, tempcplx);\n"
	"    // }\n"
	"\n"
	"  }\n"
	"}\n"
	"\n"
	"\n"
	"// quot = (fullSize / overlap_ratio) / overlap_ratio / window_size\n"
	"//calculateK(int low_in_window, int powed_stage, int windowSize)\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_Butterfly_0(__global complex * buffer,\n"
	"                        const int windowSize,\n"
	"                        const int powed_stage,\n"
	"                        const unsigned int OHalfSize,\n"
	"                        const int radixData);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_Butterfly_0(__global complex * buffer,\n"
	"                        const int windowSize,\n"
	"                        const int powed_stage,\n"
	"                        const unsigned int OHalfSize,\n"
	"                        const int radixData) {\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      unsigned int GID = o_itr + i_itr;\n"
	"      pairs butterfly_target = indexer(GID, powed_stage);\n"
	"      // 12 34 56 78\n"
	"      //(windowSize/powed_stage)\n"
	"      int k = (GID % powed_stage) * (windowSize / (2 * powed_stage));\n"
	"      //(GID%powed_stage) * (windowSize / powed_stage);\n"
	"      complex this_twiddle = twiddle(k, windowSize);\n"
	"      //complex tempcplx = cmult(buffer[butterfly_target.second], this_twiddle);\n"
	"      // if(powed_stage == 512)\n"
	"      // {\n"
	"\n"
	"      // }\n"
	"      complex first = buffer[butterfly_target.first];\n"
	"      complex second = buffer[butterfly_target.second];\n"
	"      complex tempx = cadd(first, second);\n"
	"      complex tempy = csub(first, second);\n"
	"      tempy = cmult(tempy, this_twiddle);\n"
	"      buffer[butterfly_target.first] = tempx;\n"
	"      buffer[butterfly_target.second] = tempy;\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_toPower_0(__global complex * buffer,\n"
	"                      __global float * out,\n"
	"                      const unsigned int OHalfSize,\n"
	"                      const int windowRadix);\n"
	"\n"
	"__kernel __attribute__((reqd_work_group_size(256,1,1)))\n"
	" void _occa_toPower_0(__global complex * buffer,\n"
	"                      __global float * out,\n"
	"                      const unsigned int OHalfSize,\n"
	"                      const int windowRadix) {\n"
	"  {\n"
	"    unsigned int o_itr = 0 + (256 * get_group_id(0));\n"
	"    {\n"
	"      int i_itr = 0 + get_local_id(0);\n"
	"      const unsigned int GID = o_itr + i_itr;\n"
	"      unsigned int BID = (GID >> (windowRadix - 1)) * (1 << windowRadix) + (GID & ((1 << (windowRadix - 1)) - 1));\n"
	"      float powered = cmod(buffer[BID]);\n"
	"      //powered = log10(powered);\n"
	"      out[GID] = powered;\n"
	"    }\n"
	"  }\n"
	"}\n"
	"\n"
	;

};