#ifndef ROOTISBASH  
#include "../include/kernel.okl"
#else
#include "./include/kernel.okl"
#endif

#define CUSTOM_FOR(CODES)\
QQQQFOR(0, 1024, 2048, 3072, 4096, 5120, 6144, 7168,\
8192, 9216, 10240, 11264, 12288, 13312, 14336, 15360, 16384, CODES)


@kernel void Overlap_Common(
    float* inData,
    const unsigned int OFullSize,
    const unsigned int fullSize,
    const unsigned int windowRadix,
    const unsigned int OMove,
    float* outReal)
{
    for(unsigned int o_itr=0; o_itr < OFullSize; o_itr += 1024; @outer)
    {
        for(unsigned int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            const unsigned int overlapIdx = o_itr + i_itr;
            const unsigned int windowIdx = (overlapIdx >> windowRadix);
            const unsigned int windowLocalIdx = overlapIdx & ((1 << windowRadix) - 1);
            const unsigned int originIdx = windowIdx * OMove + windowLocalIdx;
            const unsigned int exceeded = originIdx < fullSize;
            // printf("OIDX: %u, Origin: %u, WIDX: %u, WLocIdx: %u\n", 
            // overlapIdx, originIdx, windowIdx, windowLocalIdx);
            outReal[overlapIdx] = inData[originIdx * exceeded];
        }
    }
}

// @kernel void DCRemove_Common(
//     float* outReal,
//     const unsigned int OFullSize,
//     const unsigned int windowRadix
// )
// {
//     for(unsigned int o_itr=0; o_itr < OFullSize; o_itr += 1024; @outer)
//     {
//         @shared float windowBuffer[8192];//for removing DC
//         for(unsigned int i_itr=0; i_itr < 1024; ++i_itr; @inner)
//         {
//             const unsigned int overlapIdx = o_itr + i_itr;
//             const unsigned int windowIdx = (overlapIdx >> windowRadix);
//             const unsigned int windowLocalIdx = overlapIdx & ((1 << windowIdx) - 1);
            
//             outReal[overlapIdx] = inData[originIdx];
//         }
//     }
// }

@kernel void StockHamDITCommon(
    float* inReal,
    float* inImag,
    float* outReal,
    float* outImag,
    const unsigned int HwindowSize,
    const unsigned int stageRadix,
    const unsigned int OHalfSize,
    const unsigned int radixData)
{
    for(unsigned int o_itr=0; o_itr < OHalfSize; o_itr+=256; @outer)
    {
        for(unsigned int i_itr=0; i_itr < 256; ++i_itr; @inner)
        {
            unsigned int OIdx = o_itr + i_itr;
            unsigned int FwindowSize = BPOW(HwindowSize, 1);
            unsigned int GlobalItr = BDIV(OIdx, (radixData - 1));
            unsigned int GlobalIndex = BREMAIN(OIdx, HwindowSize);
            OIdx = GlobalItr * FwindowSize + GlobalIndex;
            float LeftReal = inReal[OIdx];
            float LeftImag = inImag[OIdx];
            float RightReal= inReal[OIdx + HwindowSize];
            float RightImag= inImag[OIdx + HwindowSize];

            unsigned int segmentSize = BPOW(1, stageRadix);
            unsigned int segmentItr = BDIV(GlobalIndex, stageRadix);
            unsigned int segmentIndex = BREMAIN(GlobalIndex, segmentSize);//OIdx & (segmentSize - 1);
            unsigned int LeftStoreIdx
            = segmentItr * (BPOW(segmentSize, 1)) + segmentIndex + GlobalItr * FwindowSize;

            unsigned int RightStoreIdx = LeftStoreIdx + segmentSize;
            
            // printf("L: %u, R: %u\n", OIdx, stageRadix);
            // printf("segmentK: %d\n", segmentK(
            //             GlobalIndex,
            //             segmentSize,
            //             HwindowSize
            //         ));
            
            complex tw 
            = twiddle(
                segmentK(
                        GlobalIndex,
                        segmentSize,
                        HwindowSize
                    ),
                FwindowSize
            );

            float RTwid = RMult(RightReal, tw.real, RightImag, tw.imag);
            float ITwid = IMult(RightReal, tw.real, RightImag, tw.imag);

            outReal[LeftStoreIdx] = LeftReal + RTwid;
            outImag[LeftStoreIdx] = LeftImag + ITwid;
            outReal[RightStoreIdx] = LeftReal - RTwid;
            outImag[RightStoreIdx] = LeftImag - ITwid;
        }
    }
}
// @kernel void Stockhpotimized15(complex* buffer, const unsigned int OHalfSize)
// {
//     for(unsigned int o_itr = 0; o_itr < OHalfSize; o_itr += 16384; @outer)
//     {
//         @shared complex FBank[32768];
//         @shared complex SBank[32768];
        
//         CUSTOM_FOR(
//         {
//             complex thisTwiddle = twiddle(segmentK(i_itr, 16384, 16384), 32768);
            
//             complex LEFT = buffer[o_itr * 2 + i_itr];
//             complex RIGHT= buffer[o_itr * 2 + i_itr + 16384];
//             complex storeL = cadd(LEFT, RIGHT);
//             complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);
//             SBank[i_itr] = storeL;
//             SBank[i_itr + 16384] = storeR;
//         }
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(8192, 8191, 12, 13, 16384, 32768);
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(4096, 4095, 11, 12, 16384, 32768);
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(2048, 2047, 11, 12, 16384, 32768);
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(1024, 1023, 10, 11, 16384, 32768);
//         )

//         CUSTOM_FOR(
//             OpSthmSecondTF(512, 511, 9, 10, 16384, 32768);
//         )

//         CUSTOM_FOR(
//             OpSthmFirstTS(256, 255, 8, 9, 16384, 32768)
//         )

//         CUSTOM_FOR(
//             OpSthmSecondTF(128, 127, 7, 8, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(64, 63, 6, 7, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(32, 31, 5, 6, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(16, 15, 4, 5, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(8, 7, 3, 4, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(4, 3, 2, 3, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(2, 1, 1, 2, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             complex thisTwiddle = twiddle(segmentK(i_itr, 1, 16384), 32768);
            
//             unsigned int LeftIndex =  (i_itr << 1);
            
//             complex LEFT = FBank[LeftIndex];
//             complex RIGHT= FBank[LeftIndex + 1];
//             complex storeL = cadd(LEFT, RIGHT);
//             complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);

//             buffer[o_itr * 2 + i_itr] = storeL;
//             buffer[o_itr * 2 + i_itr + 16384] = storeR;
//         )
//     }
// }


// @kernel void preprocessed_ODW15_STH_STFT(
//     float* inData,
//     const unsigned int qtConst,
//     const unsigned int fullSize,
//     const unsigned int OMove,
//     const unsigned int OHalfSize,
//     complex* bufferOut)
// {
//     for(unsigned int o_itr=0; o_itr < OHalfSize; o_itr += 16384; @outer)
//     {
//         @shared complex FBank[32768];
//         @shared complex SBank[32768];
//         @shared float   windowAdded[16384];
//         CUSTOM_FOR(//overlap and extends
        
//             unsigned int q_itr = o_itr >> 14;
//             unsigned int idx = q_itr * OMove + i_itr;
//             unsigned int Ridx = q_itr * OMove + i_itr + 16384;
//             int isOverflowed = (idx < fullSize);
//             int RisOverflowed= (Ridx< fullSize);
//             idx *= isOverflowed;
//             Ridx*=RisOverflowed;
//             FBank[i_itr].real = inData[idx] * isOverflowed;
//             FBank[i_itr].imag = 0;
//             FBank[i_itr + 16384].real = inData[Ridx] * RisOverflowed;
//             FBank[i_itr + 16384].imag = 0;
//         )

//         CUSTOM_FOR(//removing DC
        
//             float Dpoint = FBank[i_itr].real;
//             float Apoint = FBank[i_itr + (16384)].real;
//             windowAdded[i_itr] = (Dpoint + Apoint);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 8192, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 4096, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 2048, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 1024, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 512, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 256, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 128, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 64, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 32, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 16, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 8, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 4, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 2, windowAdded);
//         )
//         CUSTOM_FOR(
//             DaCAdd(i_itr, 1, windowAdded);
//         )
//         CUSTOM_FOR(
//             FBank[i_itr].real -= (windowAdded[0] / 32768.0);
//             FBank[i_itr].real *= window_func(i_itr, 32768);
//             FBank[i_itr + 16384].real -= (windowAdded[0] / 32768.0);
//             FBank[i_itr + 16384].real *= window_func(i_itr + 16384, 32768);
//         )

//         CUSTOM_FOR(
//             complex thisTwiddle = twiddle(segmentK(i_itr, 16384, 16384), 32768);
            
//             complex LEFT = FBank[i_itr];
//             complex RIGHT= FBank[i_itr + 16384];
//             complex storeL = cadd(LEFT, RIGHT);
//             complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);
//             SBank[i_itr] = storeL;
//             SBank[i_itr + 16384] = storeR;
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(8192, 8191, 13, 14, 16384, 32768);
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(4096, 4095, 12, 13, 16384, 32768);
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(2048, 2047, 11, 12, 16384, 32768);
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(1024, 1023, 10, 11, 16384, 32768);
//         )

//         CUSTOM_FOR(
//             OpSthmSecondTF(512, 511, 9, 10, 16384, 32768);
//         )

//         CUSTOM_FOR(
//             OpSthmFirstTS(256, 255, 8, 9, 16384, 32768)
//         )

//         CUSTOM_FOR(
//             OpSthmSecondTF(128, 127, 7, 8, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(64, 63, 6, 7, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(32, 31, 5, 6, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(16, 15, 4, 5, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(8, 7, 3, 4, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmFirstTS(4, 3, 2, 3, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             OpSthmSecondTF(2, 1, 1, 2, 16384, 32768)
//         )
//         CUSTOM_FOR(
//             complex thisTwiddle = twiddle(segmentK(i_itr, 1, 16384), 32768);
            
//             unsigned int LeftIndex =  (i_itr << 1);
            
//             complex LEFT = FBank[LeftIndex];
//             complex RIGHT= FBank[LeftIndex + 1];
//             complex storeL = cadd(LEFT, RIGHT);
//             complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);

//             bufferOut[o_itr * 2 + i_itr] = storeL;
//             bufferOut[o_itr * 2 + i_itr + 16384] = storeR;
//         )
//     }
// }
#undef CUSTOM_FOR