#ifndef KERNEL_GUARD
#define KERNEL_GUARD

#ifdef __NEED_PI
#include <math.h>
#endif
// #include <math.h>

#define BPOW(DATA, N) DATA << N
#define BDIV(DATA, N) DATA >> N
#define BREMAIN(DATA, N) (DATA & (N - 1))

typedef struct complex_t{
    float real;
    float imag;
}complex;

typedef struct pairs_t{
    unsigned int first;
    unsigned int second;
}pairs;


inline 
float 
window_func(const int index, const int window_size) {
    float normalized_index = (float)index;
    normalized_index /= ((float)(window_size - 1));
    float angle = 2.0f * M_PI * normalized_index;
    return 0.5f * (1.0f - cos(angle));
}


inline int 
reverseBits(int num, int radix_2_data) {
    int reversed = 0;
    for (int i = 0; i < radix_2_data; ++i) {
        reversed = (reversed << 1) | (num & 1);
        num >>= 1;
    }
    return reversed;
}


pairs 
indexer(const unsigned int firstMaximumID, const int powed_stage)
{
    pairs temp;
    temp.first = firstMaximumID + (firstMaximumID & (~(powed_stage - 1)));
    temp.second = temp.first + powed_stage;
    return temp;
}


inline
int 
segmentK(const int lsave, const int segmentSize, const int HwindowSize)
{
    return ((lsave % segmentSize) * HwindowSize) / segmentSize;
}

complex 
twiddle(int k, int windowSize)
{
    complex temp;
    float angle = -2.0 * M_PI * ((float)k / (float)windowSize);
    temp.real = cos(angle);
    temp.imag = sin(angle);
    return temp;
}

inline 
complex  
cmult(const complex a, const complex b){
    complex result;
    result.real = a.real * b.real - a.imag * b.imag;
    result.imag = a.real * b.imag + a.imag * b.real;

    return result;
}

inline
float
RMult(const float Ra, const float Rb, const float Ia, const float Ib)
{
    return (Ra * Rb) - (Ia * Ib);
}
inline
float
IMult(const float Ra, const float Rb, const float Ia, const float Ib)
{
    return (Ra * Ib) + (Ia * Rb);
}

inline
complex
cadd(complex a, const complex b){
    a.real += b.real;
    a.imag += b.imag;
    return a;
}

inline
complex
csub(complex a, const complex b){
    a.real -= b.real;
    a.imag -= b.imag;
    return a;
}

inline 
float 
cmod(complex a){
    return (sqrt(a.real*a.real + a.imag*a.imag));
}

#define DaCAdd(i_itr, Half, windowAdded)\
unsigned int inRange = i_itr < Half;\
float Dpoint = windowAdded[i_itr];\
float Apoint = windowAdded[i_itr + (Half * inRange)];\
windowAdded[i_itr] = (Dpoint + Apoint) * inRange;


#define OpSthmSecondTF(SEG, SEGMO, SEGR, SEGRPO, HW, WINDOWSIZE)\
complex thisTwiddle = twiddle(segmentK(i_itr, SEG, HW), WINDOWSIZE);\
unsigned int LeftIndex = (i_itr & SEGMO) | ((i_itr >> SEGR) << SEGRPO);\
\
complex LEFT;\
complex RIGHT;\
LEFT.real = SRBank[LeftIndex];\
LEFT.imag = SIBank[LeftIndex];\
RIGHT.real= SRBank[LeftIndex + SEG];\
RIGHT.imag= SIBank[LeftIndex + SEG];\
complex storeL = cadd(LEFT, RIGHT);\
complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);\
\
FRBank[i_itr] = storeL.real;\
FIBank[i_itr] = storeL.imag;\
FRBank[i_itr + HW] = storeR.real;\
FIBank[i_itr + HW] = storeR.imag;

#define OpSthmFirstTS(SEG, SEGMO, SEGR, SEGRPO, HW, WINDOWSIZE)\
complex thisTwiddle = twiddle(segmentK(i_itr, SEG, HW), WINDOWSIZE);\
unsigned int LeftIndex = (i_itr & SEGMO) | ((i_itr >> SEGR) << SEGRPO);\
\
complex LEFT;\
complex RIGHT;\
LEFT.real = FRBank[LeftIndex];\
LEFT.imag = FIBank[LeftIndex];\
RIGHT.real= FRBank[LeftIndex + SEG];\
RIGHT.imag= FIBank[LeftIndex + SEG];\
complex storeL = cadd(LEFT, RIGHT);\
complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);\
\
SRBank[i_itr] = storeL.real;\
SIBank[i_itr] = storeL.imag;\
SRBank[i_itr + HW] = storeR.real;\
SIBank[i_itr + HW] = storeR.imag;

@kernel void bitReverse_temp(
                        complex* buffer,
                        complex* result,
                        const unsigned int OFullSize,
                        const int windowSize,
                        const int radixData)
{
    for(unsigned int o_itr=0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int w_itr=0; w_itr < 256; ++w_itr; @inner)
        {
            unsigned int Gidx = (o_itr + w_itr);
            unsigned int Lidx = (Gidx % windowSize);
            unsigned int dst_idx = reverseBits(Lidx, radixData);
            unsigned int BID = Gidx - Lidx + dst_idx;
            result[BID] = buffer[Gidx];
        }
    }
}


@kernel void toPower(   float* out,
                        float* Real,
                        float* Imag,
                        const unsigned int OFullSize,
                        const int windowRadix)
{
    for(unsigned int o_itr = 0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        {
            const unsigned int GID = o_itr + i_itr;
            float R = Real[GID];
            float I = Imag[GID];
            out[GID] = sqrt(R * R + I * I);
        }
    }
    return;
}






#define G2FDIT(windowRadix_M1, HWindowSize, FWindowSize)\
            unsigned int Gidx = o_itr + i_itr;\
            unsigned int GlobalItr = BDIV(Gidx, windowRadix_M1);\
            unsigned int GlobalIndex = BREMAIN(Gidx, HWindowSize);\
            Gidx = GlobalItr * FWindowSize + GlobalIndex;\
            float LeftReal = Rout[Gidx];\
            float LeftImag = 0;\
            float RightReal= Rout[Gidx + HWindowSize];\
            float RightImag= 0;\
            unsigned int LeftStoreIdx = i_itr * 2;\
            unsigned int RightStoreIdx = LeftStoreIdx + 1;\
\
            complex tw\
            = twiddle(\
                segmentK(\
                    i_itr,\
                    1,\
                    HWindowSize),\
                FWindowSize);\
            float RTwid = RMult(RightReal, tw.real, RightImag, tw.imag);\
            float ITwid = IMult(RightReal, tw.real, RightImag, tw.imag);\
\
            FRBank[LeftStoreIdx] = LeftReal + RTwid;\
            FIBank[LeftStoreIdx] = LeftImag + ITwid;\
            FRBank[RightStoreIdx] = LeftReal - RTwid;\
            FIBank[RightStoreIdx] = LeftImag - ITwid;
            

#define F2SDIT(segmentSize, DsegmentSize, segmentRadix, HwindowSize, FwindowSize)\
    float LeftReal = FRBank[i_itr];\
    float LeftImag = FIBank[i_itr];\
    float RightReal= FRBank[i_itr + HwindowSize];\
    float RightImag= FIBank[i_itr + HwindowSize];\
\
    unsigned int segmentItr = BDIV(i_itr, segmentRadix);\
    unsigned int segmentIndex = BREMAIN(i_itr, segmentSize);\
    unsigned int LeftStoreIdx\
    = segmentItr * DsegmentSize + segmentIndex;\
\
    unsigned int RightStoreIdx = LeftStoreIdx + segmentSize;\
\
    complex tw\
    = twiddle(\
        segmentK(\
            i_itr,\
            segmentSize,\
            HwindowSize),\
        FwindowSize);\
    float RTwid = RMult(RightReal, tw.real, RightImag, tw.imag);\
    float ITwid = IMult(RightReal, tw.real, RightImag, tw.imag);\
\
    SRBank[LeftStoreIdx] = LeftReal + RTwid;\
    SIBank[LeftStoreIdx] = LeftImag + ITwid;\
    SRBank[RightStoreIdx] = LeftReal - RTwid;\
    SIBank[RightStoreIdx] = LeftImag - ITwid;


#define S2FDIT(segmentSize, DsegmentSize, segmentRadix, HwindowSize, FwindowSize)\
    float LeftReal = SRBank[i_itr];\
    float LeftImag = SIBank[i_itr];\
    float RightReal= SRBank[i_itr + HwindowSize];\
    float RightImag= SIBank[i_itr + HwindowSize];\
\
    unsigned int segmentItr = BDIV(i_itr, segmentRadix);\
    unsigned int segmentIndex = BREMAIN(i_itr, segmentSize);\
    unsigned int LeftStoreIdx\
    = segmentItr * DsegmentSize + segmentIndex;\
\
    unsigned int RightStoreIdx = LeftStoreIdx + segmentSize;\
\
    complex tw\
    = twiddle(\
        segmentK(\
            i_itr,\
            segmentSize,\
            HwindowSize),\
        FwindowSize);\
    float RTwid = RMult(RightReal, tw.real, RightImag, tw.imag);\
    float ITwid = IMult(RightReal, tw.real, RightImag, tw.imag);\
\
    FRBank[LeftStoreIdx] = LeftReal + RTwid;\
    FIBank[LeftStoreIdx] = LeftImag + ITwid;\
    FRBank[RightStoreIdx] = LeftReal - RTwid;\
    FIBank[RightStoreIdx] = LeftImag - ITwid;


#define F2GDIT(windowRadix_M1, HWindowSize, FWindowSize)\
            unsigned int Gidx = o_itr + i_itr;\
            unsigned int GlobalItr = BDIV(Gidx, windowRadix_M1);\
            float LeftReal = FRBank[i_itr];\
            float LeftImag = FIBank[i_itr];\
            float RightReal= FRBank[i_itr + HWindowSize];\
            float RightImag= FIBank[i_itr + HWindowSize];\
            unsigned int LeftStoreIdx\
            = i_itr + GlobalItr * FWindowSize;\
\
            unsigned int RightStoreIdx = LeftStoreIdx + HWindowSize;\
\
            complex tw\
            = twiddle(\
                segmentK(\
                    i_itr,\
                    HWindowSize,\
                    HWindowSize),\
                FWindowSize);\
            float RTwid = RMult(RightReal, tw.real, RightImag, tw.imag);\
            float ITwid = IMult(RightReal, tw.real, RightImag, tw.imag);\
\
            Rout[LeftStoreIdx] = LeftReal + RTwid;\
            Iout[LeftStoreIdx] = LeftImag + ITwid;\
            Rout[RightStoreIdx] = LeftReal - RTwid;\
            Iout[RightStoreIdx] = LeftImag - ITwid;

#define S2GDIT(windowRadix_M1, HWindowSize, FWindowSize)\
            unsigned int Gidx = o_itr + i_itr;\
            unsigned int GlobalItr = BDIV(Gidx, windowRadix_M1);\
            float LeftReal = SRBank[i_itr];\
            float LeftImag = SIBank[i_itr];\
            float RightReal= SRBank[i_itr + HWindowSize];\
            float RightImag= SIBank[i_itr + HWindowSize];\
            unsigned int LeftStoreIdx\
            = i_itr + GlobalItr * FWindowSize;\
\
            unsigned int RightStoreIdx = LeftStoreIdx + HWindowSize;\
\
            complex tw\
            = twiddle(\
                segmentK(\
                    i_itr,\
                    HWindowSize,\
                    HWindowSize),\
                FWindowSize);\
            float RTwid = RMult(RightReal, tw.real, RightImag, tw.imag);\
            float ITwid = IMult(RightReal, tw.real, RightImag, tw.imag);\
\
            Rout[LeftStoreIdx] = LeftReal + RTwid;\
            Iout[LeftStoreIdx] = LeftImag + ITwid;\
            Rout[RightStoreIdx] = LeftReal - RTwid;\
            Iout[RightStoreIdx] = LeftImag - ITwid;


#endif