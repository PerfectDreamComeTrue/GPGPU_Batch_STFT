#ifndef KERNEL_GUARD
#define KERNEL_GUARD

#ifdef __NEED_PI
#include <math.h>
#endif


#define BPOW(DATA, N) DATA << N
#define BDIV(DATA, N) DATA >> N
#define BREMAIN(DATA, N) (DATA & (N - 1))

typedef struct complex_t{
    float real;
    float imag;
}complex;

typedef struct pairs_t{
    unsigned int first;
    unsigned int second;
}pairs;


inline 
float 
window_func(const int index, const int window_size) {
    float normalized_index = (float)index;
    normalized_index /= ((float)(window_size - 1));
    float angle = 2.0f * M_PI * normalized_index;
    return 0.5f * (1.0f - cos(angle));
}


inline int 
reverseBits(int num, int radix_2_data) {
    int reversed = 0;
    for (int i = 0; i < radix_2_data; ++i) {
        reversed = (reversed << 1) | (num & 1);
        num >>= 1;
    }
    return reversed;
}


pairs 
indexer(const unsigned int firstMaximumID, const int powed_stage)
{
    pairs temp;
    temp.first = firstMaximumID + (firstMaximumID & (~(powed_stage - 1)));
    temp.second = temp.first + powed_stage;
    return temp;
}


inline
int 
segmentK(const int lsave, const int segmentSize, const int HwindowSize)
{
    return ((lsave % segmentSize) * HwindowSize) / segmentSize;
}

complex 
twiddle(int k, int windowSize)
{
    complex temp;
    float angle = -2.0 * M_PI * ((float)k / (float)windowSize);
    temp.real = cos(angle);
    temp.imag = sin(angle);
    return temp;
}

inline 
complex  
cmult(const complex a, const complex b){
    complex result;
    result.real = a.real * b.real - a.imag * b.imag;
    result.imag = a.real * b.imag + a.imag * b.real;

    return result;
}

inline
float
RMult(const float Ra, const float Rb, const float Ia, const float Ib)
{
    return (Ra * Rb) - (Ia * Ib);
}
inline
float
IMult(const float Ra, const float Rb, const float Ia, const float Ib)
{
    return (Ra * Ib) + (Ia * Rb);
}

inline
complex
cadd(complex a, const complex b){
    a.real += b.real;
    a.imag += b.imag;
    return a;
}

inline
complex
csub(complex a, const complex b){
    a.real -= b.real;
    a.imag -= b.imag;
    return a;
}

inline 
float 
cmod(complex a){
    return (sqrt(a.real*a.real + a.imag*a.imag));
}

#define DaCAdd(i_itr, Half, windowAdded)\
unsigned int inRange = i_itr < Half;\
float Dpoint = windowAdded[i_itr];\
float Apoint = windowAdded[i_itr + (Half * inRange)];\
windowAdded[i_itr] = (Dpoint + Apoint) * inRange;



// inline
// void
// DaCAdd( const int i_itr,
//         const unsigned int Half,
//         float windowAdded[])
// {
// }


#define OpSthmSecondTF(SEG, SEGMO, SEGR, SEGRPO, HW, WINDOWSIZE)\
complex thisTwiddle = twiddle(segmentK(i_itr, SEG, HW), WINDOWSIZE);\
unsigned int LeftIndex = (i_itr & SEGMO) | ((i_itr >> SEGR) << SEGRPO);\
\
complex LEFT;\
complex RIGHT;\
LEFT.real = SRBank[LeftIndex];\
LEFT.imag = SIBank[LeftIndex];\
RIGHT.real= SRBank[LeftIndex + SEG];\
RIGHT.imag= SIBank[LeftIndex + SEG];\
complex storeL = cadd(LEFT, RIGHT);\
complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);\
\
FRBank[i_itr] = storeL.real;\
FIBank[i_itr] = storeL.imag;\
FRBank[i_itr + HW] = storeR.real;\
FIBank[i_itr + HW] = storeR.imag;

#define OpSthmFirstTS(SEG, SEGMO, SEGR, SEGRPO, HW, WINDOWSIZE)\
complex thisTwiddle = twiddle(segmentK(i_itr, SEG, HW), WINDOWSIZE);\
unsigned int LeftIndex = (i_itr & SEGMO) | ((i_itr >> SEGR) << SEGRPO);\
\
complex LEFT;\
complex RIGHT;\
LEFT.real = FRBank[LeftIndex];\
LEFT.imag = FIBank[LeftIndex];\
RIGHT.real= FRBank[LeftIndex + SEG];\
RIGHT.imag= FIBank[LeftIndex + SEG];\
complex storeL = cadd(LEFT, RIGHT);\
complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);\
\
SRBank[i_itr] = storeL.real;\
SIBank[i_itr] = storeL.imag;\
SRBank[i_itr + HW] = storeR.real;\
SIBank[i_itr + HW] = storeR.imag;

@kernel void bitReverse_temp(
                        complex* buffer,
                        complex* result,
                        const unsigned int OFullSize,
                        const int windowSize,
                        const int radixData)
{
    for(unsigned int o_itr=0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int w_itr=0; w_itr < 256; ++w_itr; @inner)
        {
            unsigned int Gidx = (o_itr + w_itr);
            unsigned int Lidx = (Gidx % windowSize);
            unsigned int dst_idx = reverseBits(Lidx, radixData);
            unsigned int BID = Gidx - Lidx + dst_idx;
            result[BID] = buffer[Gidx];
        }
    }
}


@kernel void toPower(   float* out,
                        float* Real,
                        float* Imag,
                        const unsigned int OFullSize,
                        const int windowRadix)
{
    for(unsigned int o_itr = 0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        {
            const unsigned int GID = o_itr + i_itr;
            float R = Real[GID];
            float I = Imag[GID];
            out[GID] = sqrt(R * R + I * I);
        }
    }
    return;
}


#endif