#ifdef __NEED_PI
#define _USE_MATH_DEFINES
#include <math.h>
#endif
// #include <math.h>
// #include <cstdio>
typedef struct complex_t{
    float real;
    float imag;
}complex;

typedef struct pairs_t{
    unsigned int first;
    unsigned int second;
}pairs;

typedef struct stockhamPairs{
    unsigned int lload;
    unsigned int rload;
    unsigned int lsave;
    unsigned int rsave;
}spair;

inline 
float 
window_func(const int index, const int window_size) {
    float normalized_index = (float)index;
    normalized_index /= ((float)(window_size - 1));
    float angle = 2.0f * M_PI * normalized_index;
    return 0.5f * (1.0f - cos(angle));
}


inline int 
reverseBits(int num, int radix_2_data) {
    int reversed = 0;
    for (int i = 0; i < radix_2_data; ++i) {
        reversed = (reversed << 1) | (num & 1);
        num >>= 1;
    }
    return reversed;
}


pairs 
indexer(const unsigned int firstMaximumID, const int powed_stage)
{
    pairs temp;
    temp.first = firstMaximumID + (firstMaximumID & (~(powed_stage - 1)));
    temp.second = temp.first + powed_stage;
    return temp;
}

inline
spair
stockhamIndexer(const int localIdx, 
                const int segmentSize,
                const unsigned int HalfWinSize)
{
    spair res;
    res.lload = localIdx + (localIdx & (~(segmentSize - 1)));
    res.rload = res.lload + segmentSize;

    res.lsave = localIdx;
    res.rsave = HalfWinSize + res.lsave;
    return res;
}

// pairs
// indexing(const unsigned int ID,const int powed_stage)
// {
//     pairs temp;
//     temp.first = ID;
//     temp.second = ID + (ID % (powed_stage*2) >= powed_stage ? -powed_stage : powed_stage);
//     return temp;
// }

inline
int calculateK(int windowIDX, int powed_stage, int windowSize) {

    return ((windowIDX % powed_stage) * windowSize) / (powed_stage * 2);
}

inline
int 
segmentK(const int lsave, const int segmentSize, const int HwindowSize)
{
    // return lsave;
    // return calculateK(lsave, segmentSize, windowSize);
    return ((lsave % segmentSize) * HwindowSize) / segmentSize;
}

complex 
twiddle(int k, int windowSize)
{
    complex temp;
    float angle = -2.0 * M_PI * ((float)k / (float)windowSize);
    temp.real = cos(angle);
    temp.imag = sin(angle);
    return temp;
}

inline 
complex  
cmult(const complex a, const complex b){
    complex result;
    result.real = a.real * b.real - a.imag * b.imag;
    result.imag = a.real * b.imag + a.imag * b.real;

    return result;
}

inline
complex
cadd(complex a, const complex b){
    a.real += b.real;
    a.imag += b.imag;
    return a;
}

inline
complex
csub(complex a, const complex b){
    a.real -= b.real;
    a.imag -= b.imag;
    return a;
}

inline 
float 
cmod(complex a){
    return (sqrt(a.real*a.real + a.imag*a.imag));
}

@kernel void removeDC(  complex* buffer,
                        const unsigned int OFullSize,
                        float* qt_buffer,
                        const int windowSize)
{
    for(unsigned int o_itr = 0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        {
            unsigned int IDX = o_itr + i_itr;
            @atomic qt_buffer[IDX / windowSize] += buffer[IDX].imag;
        }
    }

    for(unsigned int o_itr = 0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int i_itr = 0; i_itr < 256; ++i_itr;@inner)
        {
            unsigned int IDX = o_itr + i_itr;
            
            buffer[IDX].imag -= (qt_buffer[IDX / windowSize] / (float)windowSize);
        }
    }

}

@kernel void overlap_N_window(  float* in,
                                complex* buffer,
                                const unsigned int fullSize,
                                const unsigned int OFullSize,
                                const int windowSize,
                                const unsigned int OMove)
{
    for(unsigned int w_num=0; w_num < OFullSize; w_num += 256; @outer)
    {
        for(int w_itr=0; w_itr < 256; ++w_itr; @inner)
        {
            unsigned int FID = w_num + w_itr;
            unsigned int read_point = 
                (unsigned int)((FID) / windowSize) * OMove + ((FID) % windowSize);
            
            // printf("%u buffer overlap\n", OMove);//buffer[FID].imag);
            
            buffer[FID].real = 
            read_point >= fullSize ? 0.0
            :
            in[read_point];// * window_func((FID) % windowSize, windowSize);
            buffer[FID].imag = 0.0;
        }
    }
}



@kernel void overlap_N_window_imag(  float* in,
                                complex* buffer,
                                const unsigned int fullSize,
                                const unsigned int OFullSize,
                                const int windowSize,
                                const unsigned int OMove)
{
    for(unsigned int w_num=0; w_num < OFullSize; w_num += 256; @outer)
    {
        for(int w_itr=0; w_itr < 256; ++w_itr; @inner)
        {
            unsigned int FID = w_num + w_itr;
            unsigned int read_point = 
                (unsigned int)((FID) / windowSize) * OMove + ((FID) % windowSize);
            
            // printf("%u buffer overlap\n", OMove);//buffer[FID].imag);
            
            buffer[FID].imag = 
            read_point >= fullSize ? 0.0
            :
            in[read_point] * window_func((FID) % windowSize, windowSize);
            buffer[FID].real = 0.0;
        }
    }
}
@kernel void bitReverse_temp(
                        complex* buffer,
                        complex* result,
                        const unsigned int OFullSize,
                        const int windowSize,
                        const int radixData)
{
    for(unsigned int o_itr=0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int w_itr=0; w_itr < 256; ++w_itr; @inner)
        {
            unsigned int Gidx = (o_itr + w_itr);
            unsigned int Lidx = (Gidx % windowSize);
            unsigned int dst_idx = reverseBits(Lidx, radixData);
            unsigned int BID = Gidx - Lidx + dst_idx;
            result[BID] = buffer[Gidx];
        }
    }
}

@kernel void bitReverse(complex* buffer,
                        const unsigned int OFullSize,
                        const int windowSize,
                        const int radixData)
{
    for(unsigned int o_itr=0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int w_itr=0; w_itr < 256; ++w_itr; @inner)
        {
            
            unsigned int dst_idx = reverseBits(((o_itr + w_itr) % windowSize), radixData);
            unsigned int BID = o_itr + w_itr - ((o_itr + w_itr) % windowSize) + dst_idx;
            buffer[BID].real = buffer[o_itr + w_itr].imag;
        }
    }
}

@kernel void endPreProcess( complex* buffer,
                            const unsigned int OFullSize)
{
    for(unsigned int o_itr=0; o_itr < OFullSize; o_itr += 256; @outer)
    {
        for(int i_itr=0; i_itr < 256; ++i_itr; @inner)
        {
            // printf("%f data buffer\n", buffer[o_itr + i_itr].real);
            buffer[o_itr + i_itr].imag = 0.0;
            
        }
    }
}


#define FirstToSecond(POWSTAGE, WINSIZE, HWINSIZE)\
for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)\
{\
    pairs idx = indexer((i_itr + o_itr) % (HWINSIZE), POWSTAGE);\
    complex cfirst = bank_first[idx.first];\
    complex csecond = bank_first[idx.second];\
\
    complex this_twiddle = twiddle(calculateK(idx.first, POWSTAGE, WINSIZE), WINSIZE);\
    complex tempcplx = cmult(csecond, this_twiddle);\
\
\
    bank_second[idx.first] = cadd(cfirst, csecond);\
    bank_second[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\
\
    pairs Gidx = indexer(i_itr + o_itr, POWSTAGE);\
    buffer[Gidx.first] = bank_second[idx.first];\
    buffer[Gidx.second] = bank_second[idx.second];\
\
}


#define SecondToFirst(POWSTAGE, WINSIZE, HWINSIZE)\
for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)\
{\
    pairs idx = indexer((i_itr + o_itr) % (HWINSIZE), POWSTAGE);\
    complex cfirst = bank_second[idx.first];\
    complex csecond = bank_second[idx.second];\
\
    complex this_twiddle = twiddle(calculateK(idx.first, POWSTAGE, WINSIZE), WINSIZE);\
    complex tempcplx = cmult(csecond, this_twiddle);\
\
    bank_first[idx.first] = cadd(cfirst, csecond);\
    bank_first[idx.second] = cmult(csub(cfirst, csecond), this_twiddle);\
\
    pairs Gidx = indexer(i_itr + o_itr, POWSTAGE);\
    buffer[Gidx.first] = bank_first[idx.first];\
    buffer[Gidx.second] = bank_first[idx.second];\
\
}

#define SthmFirstToSecond(SEGMENTSIZE, HWINSIZE, WINDOWSIZE)\
spair lidx = stockhamIndexer(i_itr, SEGMENTSIZE, HWINSIZE);\
complex thisTwiddle = twiddle(segmentK(lidx.lsave, SEGMENTSIZE, HWINSIZE), WINDOWSIZE);\
complex cfirst = bank_first[lidx.lload];\
complex csecond= bank_first[lidx.rload];\
bank_second[lidx.lsave] = cadd(cfirst, csecond);\
bank_second[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);

#define SthmSecondToFirst(SEGMENTSIZE, HWINSIZE, WINDOWSIZE)\
spair lidx = stockhamIndexer(i_itr, SEGMENTSIZE, HWINSIZE);\
complex thisTwiddle = twiddle(segmentK(lidx.lsave, SEGMENTSIZE, HWINSIZE), WINDOWSIZE);\
complex cfirst = bank_second[lidx.lload];\
complex csecond= bank_second[lidx.rload];\
bank_first[lidx.lsave] = cadd(cfirst, csecond);\
bank_first[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);


@kernel void StockhamButterfly10(complex* buffer, const unsigned int OHalfSize)
{
    for(unsigned int o_itr = 0; o_itr < OHalfSize; o_itr += 512; @outer)
    {
        @shared complex bank_first[1024];
        @shared complex bank_second[1024];
        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            unsigned int global_idx = (o_itr + i_itr);
            pairs idx = indexer(global_idx, 512);
            
            spair lidx = stockhamIndexer(i_itr, 512, 512);
            complex thisTwiddle = twiddle(segmentK(lidx.lsave, 512, 512), 1024);
            complex cfirst = buffer[idx.first];
            complex csecond= buffer[idx.second];
            bank_second[lidx.lsave] = cadd(cfirst, csecond);
            bank_second[lidx.rsave] = cmult(csub(cfirst, csecond), thisTwiddle);
        }
        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmSecondToFirst(256, 512, 1024)
        }
        
        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmFirstToSecond(128, 512, 1024)
        }

        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmSecondToFirst(64, 512, 1024)
        }

        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmFirstToSecond(32, 512, 1024)
        }

        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmSecondToFirst(16, 512, 1024)
        }

        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmFirstToSecond(8, 512, 1024)
        }

        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmSecondToFirst(4, 512, 1024)
        }

        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            SthmFirstToSecond(2, 512, 1024)
        }

        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            pairs GIDX;
            GIDX.first = o_itr * 2 + i_itr;
            GIDX.second= GIDX.first + 512;
            spair lidx = stockhamIndexer(i_itr, 1, 512);
            complex thisTwiddle = twiddle(segmentK(lidx.lsave, 1, 512), 1024);
            complex cfirst = bank_second[lidx.lload];
            complex csecond= bank_second[lidx.rload];
            buffer[GIDX.first] = cadd(cfirst, csecond);
            buffer[GIDX.second] = cmult(csub(cfirst, csecond), thisTwiddle);
        }

        // for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        // {
        //     pairs GIDX;
        //     GIDX.first = o_itr * 2 + i_itr;
        //     GIDX.second= GIDX.first + 512;
        //     buffer[GIDX.first] = bank_first[i_itr];
        //     buffer[GIDX.second] = bank_first[i_itr + 512];
        // }
    }
}


// printf("%d STKstage k = %d\n", POWSTAGE, calculateK(idx.first, POWSTAGE, WINSIZE));

@kernel void OptimizedDIFButterfly10( complex* buffer, const unsigned int OHalfSize)
{
    
    for(unsigned int o_itr = 0; o_itr < OHalfSize; o_itr += 512; @outer)
    {
        @shared complex bank_first[1024];
        @shared complex bank_second[1024];
        for(int i_itr = 0; i_itr < 512; ++i_itr; @inner)
        {
            int global_idx = (o_itr + i_itr);
            pairs idx = indexer(global_idx, 512);
            pairs Lidx = indexer((i_itr + o_itr) % 512 , 512);
            complex cfirst = buffer[idx.first];
            complex csecond = buffer[idx.second];

            complex this_twiddle = twiddle(calculateK(i_itr, 512, 1024), 1024);
            
            // printf("first: %f second: %f  idx: %u\n", cfirst.real, csecond.real, idx.first);


            bank_second[Lidx.first] = cadd(cfirst, csecond);
            bank_second[Lidx.second] = cmult(csub(cfirst, csecond), this_twiddle);
            //debug
            buffer[idx.first] = bank_second[Lidx.first];
            buffer[idx.second] = bank_second[Lidx.second];
            //debug
        }
        SecondToFirst(256, 1024, 512)

        FirstToSecond(128, 1024, 512)
        SecondToFirst(64, 1024, 512)
        FirstToSecond(32, 1024, 512)
        SecondToFirst(16, 1024, 512)
        FirstToSecond(8, 1024, 512)
        SecondToFirst(4, 1024, 512)
        FirstToSecond(2, 1024, 512)
        SecondToFirst(1, 1024, 512)
        // for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        // {
        //     @barrier();
        //     pairs idx = indexer((i_itr + o_itr) % (1024 / 2), 512);
        //     complex cfirst = bank_second[idx.first];
        //     complex csecond = bank_second[idx.second];

        //     complex this_twiddle = twiddle(calculateK(idx.first, 512, 1024), 1024);
        //     complex tempcplx = cmult(csecond, this_twiddle);

        //     pairs Gidx = indexer(i_itr + o_itr, 512);
        //     buffer[Gidx.first] = cadd(cfirst, tempcplx);
        //     buffer[Gidx.second] = csub(cfirst, tempcplx);

        //     bank_first[idx.first] = cadd(cfirst, tempcplx);
        //     bank_first[idx.second] = csub(cfirst, tempcplx);
        // }
        // for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        // {
        //     pairs idx = indexer(i_itr, 256);
        //     complex cfirst = bank_first[idx.first];
        //     complex csecond = bank_first[idx.second];

        //     complex this_twiddle = twiddle(calculateK(idx.first, 256, 1024), 1024);
        //     complex tempcplx = cmult(csecond, this_twiddle);
        //     pairs GIDX = indexer(o_itr + i_itr, 256);
        //     buffer[GIDX.first] = cadd(cfirst, tempcplx);
        //     buffer[GIDX.second] = csub(cfirst, tempcplx);
            
        // }
        
        // for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        // {
        //     pairs LIDX = indexer((i_itr + o_itr) % 512, 512);
        //     pairs GIDX = indexer(i_itr + o_itr, 512);
        //     // o_itr = 432153245;
        //     complex cfirst = buffer[GIDX.first];
        //     complex csecond = buffer[GIDX.second];
        //     // printf("GDIX F : %d, S : %d\n", GIDX.first, GIDX.second);
        //     // printf("stk=%d\n", calculateK(LIDX.first, 512, 1024));
        //     complex this_twiddle = twiddle(calculateK(GIDX.first, 512, 1024), 1024);
        //     complex tempcplx = cmult(csecond, this_twiddle);
        //     printf("%f , %f idx: %d idxS: %d\n", csecond.real, cfirst.real, GIDX.first, GIDX.second);
        //     buffer[GIDX.first] = cadd(cfirst, tempcplx);
        //     buffer[GIDX.second] = csub(cfirst, tempcplx);
        // }

        

    }
}


// quot = (fullSize / overlap_ratio) / overlap_ratio / window_size
//calculateK(int low_in_window, int powed_stage, int windowSize)
@kernel void Butterfly( complex* buffer,
                        const int windowSize,
                        const int powed_stage,
                        const unsigned int OHalfSize,
                        const int radixData)
{
    for(unsigned int o_itr = 0; o_itr < OHalfSize; o_itr += 256; @outer)
    {
        for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        {
            unsigned int GID = o_itr + i_itr;
            pairs butterfly_target = indexer(GID, powed_stage);
            // 12 34 56 78 
            //(windowSize/powed_stage)
            int k = (GID % powed_stage) * (windowSize / (2 * powed_stage));//(GID%powed_stage) * (windowSize / powed_stage);
           
            complex this_twiddle = twiddle(k, windowSize);
            // printf("%f -- %f <gpu>> %d\n", this_twiddle.real, this_twiddle.imag, k);
            // printf("%f -- %f\n", buffer[butterfly_target.first].real, buffer[butterfly_target.second].real);
            
            //complex tempcplx = cmult(buffer[butterfly_target.second], this_twiddle);
            // if(powed_stage == 512)
            // {
            //     printf("%f , %f -- %d __ %d\n", buffer[butterfly_target.first].real, buffer[butterfly_target.second].real, butterfly_target.first, butterfly_target.second);

            // }
            complex first = buffer[butterfly_target.first];
            complex second = buffer[butterfly_target.second];
            complex tempx = cadd(first, second);
            complex tempy = csub(first, second);
            tempy = cmult(tempy, this_twiddle);
            buffer[butterfly_target.first] = tempx;
            buffer[butterfly_target.second] = tempy;                
        }
    }
}
@kernel void toPower(   complex* buffer,
                        float* out,
                        const unsigned int OHalfSize,
                        const int windowRadix)
{
    //toPower
    for(unsigned int o_itr = 0; o_itr < OHalfSize; o_itr += 256; @outer)
    {
        for(int i_itr = 0; i_itr < 256; ++i_itr; @inner)
        {
            const unsigned int GID = o_itr + i_itr;
            unsigned int BID = 
                (GID >> (windowRadix - 1)) * (1 << windowRadix)
                +
                (GID & ((1 << (windowRadix - 1)) - 1));
            float powered = cmod(buffer[BID]);
            //powered = log10(powered);
            out[GID] = powered;
        }
    }
    return;
}