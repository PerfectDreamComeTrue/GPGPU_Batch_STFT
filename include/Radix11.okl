#ifndef ROOTISBASH  
#include "../include/kernel.okl"
#else
#include "./include/kernel.okl"
#endif


@kernel void preprocesses_ODW_11(
    float* inData,
    const unsigned int qtConst,
    const unsigned int fullSize,
    const unsigned int OMove,
    complex* bufferOut   
    )
{
    for(unsigned int o_itr=0; o_itr < qtConst; ++o_itr; @outer)
    {
        @shared complex windowBuffer[2048];
        @shared float   windowAdded[1024];
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)//overlap and extends
        {
            unsigned int idx = o_itr * OMove + i_itr;
            unsigned int Ridx = o_itr * OMove + i_itr + 1024;
            int isOverflowed = (idx < fullSize);
            int RisOverflowed= (Ridx< fullSize);
            idx *= isOverflowed;
            Ridx*=RisOverflowed;
            windowBuffer[i_itr].real = inData[idx] * isOverflowed;
            windowBuffer[i_itr].imag = 0;
            windowBuffer[i_itr + 1024].real = inData[Ridx] * RisOverflowed;
            windowBuffer[i_itr + 1024].imag = 0;
            
        }

        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)//removing DC
        {
            float Dpoint = windowBuffer[i_itr].real;
            float Apoint = windowBuffer[i_itr + (1024)].real;
            windowAdded[i_itr] = (Dpoint + Apoint);
        }

        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 512, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 256, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 128, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 64, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 32, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 16, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 8, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 4, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 2, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 1, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            windowBuffer[i_itr].real -= (windowAdded[0] / 2048.0);
            windowBuffer[i_itr + 1024].real -= (windowAdded[0] / 2048.0);
            windowBuffer[i_itr].real *= window_func(i_itr, 2048);
            windowBuffer[i_itr + 1024].real *= window_func(i_itr + 1024, 2048);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {

            bufferOut[o_itr * 2048 + i_itr] = windowBuffer[i_itr];
            bufferOut[o_itr * 2048 + i_itr + 1024] = windowBuffer[i_itr + 1024];
        }   
    }
}




@kernel void Stockhpotimized11(complex* buffer, const unsigned int OHalfSize)
{
    for(unsigned int o_itr = 0; o_itr < OHalfSize; o_itr += 1024; @outer)
    {
        @shared complex FBank[2048];
        @shared complex SBank[2048];
        
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            complex thisTwiddle = twiddle(segmentK(i_itr, 1024, 1024), 2048);
            
            complex LEFT = buffer[o_itr * 2 + i_itr];
            complex RIGHT= buffer[o_itr * 2 + i_itr + 1024];
            complex storeL = cadd(LEFT, RIGHT);
            complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);
            SBank[i_itr] = storeL;
            SBank[i_itr + 1024] = storeR;
        }

        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(512, 511, 9, 10, 1024, 2048);
        }

        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(256, 255, 8, 9, 1024, 2048)
        }

        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(128, 127, 7, 8, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(64, 63, 6, 7, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(32, 31, 5, 6, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(16, 15, 4, 5, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(8, 7, 3, 4, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(4, 3, 2, 3, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(2, 1, 1, 2, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            complex thisTwiddle = twiddle(segmentK(i_itr, 1, 1024), 2048);
            
            unsigned int LeftIndex =  (i_itr << 1);
            
            complex LEFT = FBank[LeftIndex];
            complex RIGHT= FBank[LeftIndex + 1];
            complex storeL = cadd(LEFT, RIGHT);
            complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);

            buffer[o_itr * 2 + i_itr] = storeL;
            buffer[o_itr * 2 + i_itr + 1024] = storeR;
        }
    }
}


@kernel void preprocessed_ODW11_STH_STFT(
    float* inData,
    const unsigned int qtConst,
    const unsigned int fullSize,
    const unsigned int OMove,
    const unsigned int OHalfSize,
    complex* bufferOut)
{
    for(unsigned int o_itr=0; o_itr < OHalfSize; o_itr += 1024; @outer)
    {
        @shared complex FBank[2048];
        @shared complex SBank[2048];
        @shared float   windowAdded[1024];
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)//overlap and extends
        {
            unsigned int q_itr = o_itr >> 10;
            unsigned int idx = q_itr * OMove + i_itr;
            unsigned int Ridx = q_itr * OMove + i_itr + 1024;
            int isOverflowed = (idx < fullSize);
            int RisOverflowed= (Ridx< fullSize);
            idx *= isOverflowed;
            Ridx*=RisOverflowed;
            FBank[i_itr].real = inData[idx] * isOverflowed;
            FBank[i_itr].imag = 0;
            FBank[i_itr + 1024].real = inData[Ridx] * RisOverflowed;
            FBank[i_itr + 1024].imag = 0;
        }

        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)//removing DC
        {
            float Dpoint = FBank[i_itr].real;
            float Apoint = FBank[i_itr + (1024)].real;
            windowAdded[i_itr] = (Dpoint + Apoint);
        }

        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 512, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 256, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 128, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 64, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 32, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 16, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 8, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 4, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 2, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            DaCAdd(i_itr, 1, windowAdded);
        }
        for(int i_itr=0; i_itr < 1024; ++i_itr; @inner)
        {
            FBank[i_itr].real -= (windowAdded[0] / 2048.0);
            FBank[i_itr].real *= window_func(i_itr, 2048);
            FBank[i_itr + 1024].real -= (windowAdded[0] / 2048.0);
            FBank[i_itr + 1024].real *= window_func(i_itr + 1024, 2048);
        }

        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            complex thisTwiddle = twiddle(segmentK(i_itr, 1024, 1024), 2048);
            
            complex LEFT = FBank[i_itr];
            complex RIGHT= FBank[i_itr + 1024];
            complex storeL = cadd(LEFT, RIGHT);
            complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);
            SBank[i_itr] = storeL;
            SBank[i_itr + 1024] = storeR;
        }

        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(512, 511, 9, 10, 1024, 2048);
        }

        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(256, 255, 8, 9, 1024, 2048)
        }

        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(128, 127, 7, 8, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(64, 63, 6, 7, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(32, 31, 5, 6, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(16, 15, 4, 5, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(8, 7, 3, 4, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmFirstTS(4, 3, 2, 3, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            OpSthmSecondTF(2, 1, 1, 2, 1024, 2048)
        }
        for(int i_itr = 0; i_itr < 1024; ++i_itr; @inner)
        {
            complex thisTwiddle = twiddle(segmentK(i_itr, 1, 1024), 2048);
            
            unsigned int LeftIndex =  (i_itr << 1);
            
            complex LEFT = FBank[LeftIndex];
            complex RIGHT= FBank[LeftIndex + 1];
            complex storeL = cadd(LEFT, RIGHT);
            complex storeR = cmult(csub(LEFT, RIGHT), thisTwiddle);

            bufferOut[o_itr * 2 + i_itr] = storeL;
            bufferOut[o_itr * 2 + i_itr + 1024] = storeR;
        }
    }
}