
#pragma once
//generated with python code
#include <string>
class cl_embed {
    public:
    #ifndef NO_EMBEDDED_CL
std::string STFT = 
	"#define TIDX uint\n"
	"#define TIDX2 uint2\n"
	"#define FULL_LENGTH get_global_size(0)\n"
	"#define WINDOW_LENGTH get_local_size(0)\n"
	"#define GID get_global_id(0)\n"
	"#define LID get_local_id(0)\n"
	"typedef struct Dvals {\n"
	"    global float2* in;\n"
	"    global float* out;\n"
	"}DV;\n"
	"\n"
	"void DC_remover(__global short* in, __local atomic_int* sums)\n"
	"{\n"
	"    atomic_fetch_add(sums,convert_int(in[GID]));\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    in[GID] -= convert_short(atomic_load(sums)/WINDOW_LENGTH);\n"
	"}\n"
	"\n"
	"\n"
	"inline float \n"
	"window_func(const int index, const int window_size)\n"
	"{\n"
	"    return (0.42 - 0.5*cospi(2.0*(float)index/(float)window_size)+0.08*cospi(4.0*(float)index/(float)(window_size)));\n"
	"}\n"
	"\n"
	"void \n"
	"windowing(__global float2* in)\n"
	"{\n"
	"    in[GID].x = in[GID].x * window_func(LID, WINDOW_LENGTH);\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"inline int \n"
	"reverseBits(int num, int radix_2_data) {\n"
	"    private int reversed = 0;\n"
	"    for (int i = 0; i < radix_2_data; ++i) {\n"
	"        reversed = (reversed << 1) | (num & 1);\n"
	"        num >>= 1;\n"
	"    }\n"
	"    return reversed;\n"
	"}\n"
	"\n"
	"void \n"
	"bitreverse_stft(__global float2* in, int radix_2)\n"
	"{\n"
	"    private TIDX id_quot = GID / WINDOW_LENGTH;\n"
	"    TIDX calced_id = id_quot * WINDOW_LENGTH + reverseBits(LID, radix_2);\n"
	"    private TIDX2 tout;\n"
	"    tout.x = in[calced_id].x;\n"
	"    tout.y = 0.0;\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    in[GID].x = tout.x;\n"
	"    in[GID].y = tout.y;\n"
	"}\n"
	"typedef float2 cfloat;\n"
	"\n"
	"#define I ((cfloat)(0.0, 1.0))\n"
	"\n"
	"inline float  real(cfloat a){\n"
	"     return a.x;\n"
	"}\n"
	"inline float  imag(cfloat a){\n"
	"     return a.y;\n"
	"}\n"
	"\n"
	"inline float cmod(cfloat a){\n"
	"    return (sqrt(a.x*a.x + a.y*a.y));\n"
	"}\n"
	"inline float carg(cfloat a){\n"
	"    if(a.x > 0){\n"
	"        return atan(a.y / a.x);\n"
	"\n"
	"    }else if(a.x < 0 && a.y >= 0){\n"
	"        return atan(a.y / a.x) + M_PI;\n"
	"\n"
	"    }else if(a.x < 0 && a.y < 0){\n"
	"        return atan(a.y / a.x) - M_PI;\n"
	"\n"
	"    }else if(a.x == 0 && a.y > 0){\n"
	"        return M_PI/2;\n"
	"\n"
	"    }else if(a.x == 0 && a.y < 0){\n"
	"        return -M_PI/2;\n"
	"\n"
	"    }else{\n"
	"        return 0;\n"
	"    }\n"
	"}\n"
	"\n"
	"inline cfloat  cmult(cfloat a, cfloat b){\n"
	"    return (cfloat)( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n"
	"}\n"
	"\n"
	"inline cfloat cdiv(cfloat a, cfloat b){\n"
	"    return (cfloat)((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y), (a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y));\n"
	"}\n"
	"cfloat twiddle(int high, int low)\n"
	"{\n"
	"    cfloat temp;\n"
	"    float angle = 2.0*((float)high/(float)low);\n"
	"    temp.x = cospi(angle);\n"
	"    temp.y = -1.0*sinpi(angle);\n"
	"    return temp;\n"
	"}\n"
	"TIDX2 indexer(const TIDX ID,const int powed_stage)\n"
	"{\n"
	"    private TIDX2 temp;\n"
	"    temp.x = (ID%(powed_stage))+powed_stage*2*(ID/powed_stage);\n"
	"    temp.y = temp.x+powed_stage;\n"
	"    return temp;\n"
	"}\n"
	"\n"
	"void \n"
	"butterfly_stft(__global float2* in, int radix_2)\n"
	"{\n"
	"    for(int stage = 0; stage < radix_2; ++stage){\n"
	"        if(GID < (FULL_LENGTH / 2)){\n"
	"            private TIDX powed_stage = (TIDX)pow(2.0, stage);\n"
	"            private TIDX2 origin_pair = indexer(GID, powed_stage);\n"
	"            private cfloat this_twiddle = twiddle(GID % powed_stage, powed_stage * 2);\n"
	"            this_twiddle = cmult(in[origin_pair.y],this_twiddle);\n"
	"            private float2 tempx;\n"
	"            private float2 tempy;\n"
	"            tempx = in[origin_pair.x] + this_twiddle;\n"
	"            tempy = in[origin_pair.y] - this_twiddle;\n"
	"            barrier(CLK_LOCAL_MEM_FENCE);\n"
	"            in[origin_pair.x] = tempx;\n"
	"            in[origin_pair.y] = tempy;\n"
	"        }\n"
	"        else{\n"
	"            barrier(CLK_LOCAL_MEM_FENCE);\n"
	"        }\n"
	"        barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    }\n"
	"}\n"
	"#define HF_SZ(N) (N / 2)\n"
	"#define IDX(C, ID) ((ID / HF_SZ(C) * C) + (ID % HF_SZ(C)))\n"
	"void \n"
	"to_power(__global float2* in, __global float* out)\n"
	"{\n"
	"    if(GID < FULL_LENGTH / 2){\n"
	"        private float powered = cmod(in[IDX(FULL_LENGTH, GID)]);\n"
	"        out[GID] = powered;//GID % HF_SZ(core_size) < 2 ? 0 : powered;   \n"
	"    }\n"
	"}\n"
	"\n"
	"void normalization()\n"
	"{\n"
	"\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"__kernel void STFT( __global short* in,\n"
	"                    __global float2* tempBuffer,\n"
	"                    __global float* out,\n"
	"                    int overlapFrame,\n"
	"                    TIDX frameLimit,\n"
	"                    int FrontZeroPad,\n"
	"                    int windowRadix)\n"
	"{\n"
	"    local atomic_int dc_avg;\n"
	"    atomic_init(&dc_avg, 0);\n"
	"    DC_remover(in, &dc_avg);\n"
	"    private TIDX quot = GID / WINDOW_LENGTH;\n"
	"    private TIDX my_index = quot * overlapFrame + LID;\n"
	"    private float will_write;\n"
	"    \n"
	"    will_write = frameLimit <= my_index ? 0 : convert_float(in[my_index]);\n"
	"    will_write = LID < FrontZeroPad ? 0 : will_write;\n"
	"    tempBuffer[GID].x = will_write;\n"
	"    tempBuffer[GID].y = 0;\n"
	"    windowing(tempBuffer);\n"
	"    bitreverse_stft(tempBuffer, windowRadix);\n"
	"    butterfly_stft(tempBuffer, windowRadix);\n"
	"    to_power(tempBuffer, out);\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"// __kernel void \n"
	"// overlap(__global short* in,\n"
	"//         __global float2* out,\n"
	"//         int overlap_frame,\n"
	"//         TIDX frame_limit, \n"
	"//         int front_side_zero_padding_size)\n"
	"// {\n"
	"//     local atomic_int dc_avg;\n"
	"//     atomic_init(&dc_avg, 0);\n"
	"//     DC_remover(in, &dc_avg);\n"
	"//     private TIDX quot = GID / WINDOW_LENGTH;\n"
	"//     private TIDX my_index = quot * overlap_frame + LID;\n"
	"//     private float will_write;\n"
	"    \n"
	"//     will_write = frame_limit <= my_index ? 0 : convert_float(in[my_index]);\n"
	"//     will_write = LID < front_side_zero_padding_size ? 0 : will_write;\n"
	"//     out[GID].x = will_write;\n"
	"//     out[GID].y = 0;\n"
	"// }\n"
	"\n"
	"\n"
	"// // __kernel void STFT(__global float2* in_frame, __global float* out_frame, int radix_window)\n"
	"// // {\n"
	"    \n"
	"// //     windowing(in_frame);\n"
	"// //     bitreverse_stft(in_frame, radix_window);\n"
	"// //     butterfly_stft(in_frame, radix_window);\n"
	"// //     to_power(in_frame, out_frame);\n"
	"// // }\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string STFT = 
	"CL_C_kernel_files/STFT.cl\n"
	;
#endif

};